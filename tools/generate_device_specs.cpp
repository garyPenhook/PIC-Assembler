/**
 * Generate device_specs_generated.h from device_memory_specs.txt
 * 
 * Reads the device memory specifications from a text file and generates
 * the C++ header file with proper DeviceSpec structures.
 */
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <algorithm>
#include <cctype>
#include <cstdint>
struct DeviceSpec {
    std::string name;
    uint32_t programMemoryWords;
    uint32_t dataMemoryBytes;
    uint32_t eepromBytes;
    std::string architecture;
};
std::string trim(const std::string& str) {
    size_t start = str.find_first_not_of(" \t\r\n");
    if (start == std::string::npos) return "";
    size_t end = str.find_last_not_of(" \t\r\n");
    return str.substr(start, end - start + 1);
}
std::vector<std::string> split(const std::string& str, char delimiter) {
    std::vector<std::string> tokens;
    std::stringstream ss(str);
    std::string token;
    while (std::getline(ss, token, delimiter)) {
        tokens.push_back(trim(token));
    }
    return tokens;
}
bool parseSpecLine(const std::string& line, DeviceSpec& spec) {
    // Skip comments and empty lines
    std::string trimmed = trim(line);
    if (trimmed.empty() || trimmed[0] == '#') {
        return false;
    }
    // Parse: DEVICE_NAME, PROGRAM_MEMORY_WORDS, DATA_MEMORY_BYTES, EEPROM_BYTES, ARCHITECTURE
    std::vector<std::string> parts = split(line, ',');
    if (parts.size() != 5) {
        return false;
    }
    try {
        spec.name = parts[0];
        spec.programMemoryWords = std::stoul(parts[1]);
        spec.dataMemoryBytes = std::stoul(parts[2]);
        spec.eepromBytes = std::stoul(parts[3]);
        spec.architecture = parts[4];
        return true;
    } catch (...) {
        return false;
    }
}
int main(int argc, char* argv[]) {
    std::string inputFile = "device_memory_specs.txt";
    std::string outputFile = "device_specs_generated.h";
    if (argc >= 2) {
        inputFile = argv[1];
    }
    if (argc >= 3) {
        outputFile = argv[2];
    }
    std::ifstream input(inputFile);
    if (!input.is_open()) {
        std::cerr << "Error: Cannot open input file: " << inputFile << std::endl;
        return 1;
    }
    std::vector<DeviceSpec> specs;
    std::string line;
    int lineNum = 0;
    while (std::getline(input, line)) {
        lineNum++;
        DeviceSpec spec;
        if (parseSpecLine(line, spec)) {
            specs.push_back(spec);
        }
    }
    input.close();
    if (specs.empty()) {
        std::cerr << "Error: No device specifications found in " << inputFile << std::endl;
        return 1;
    }
    std::cout << "Parsed " << specs.size() << " device specifications from " << inputFile << std::endl;
    // Generate output file
    std::ofstream output(outputFile);
    if (!output.is_open()) {
        std::cerr << "Error: Cannot create output file: " << outputFile << std::endl;
        return 1;
    }
    output << "/**\n";
    output << " * Auto-generated Device Specifications\n";
    output << " * Generated from: " << inputFile << "\n";
    output << " * \n";
    output << " * DO NOT EDIT THIS FILE MANUALLY\n";
    output << " * Edit device_memory_specs.txt and regenerate using generate_device_specs tool\n";
    output << " */\n\n";
    output << "#pragma once\n\n";

    for (const auto& spec : specs) {
        uint32_t programMemoryBytes = spec.programMemoryWords * 2;

        output << "    static constexpr DeviceSpec " << spec.name << "_SPEC{\n";
        output << "        \"" << spec.name << "\",\n";
        output << "        " << programMemoryBytes << ",      // program memory (" 
               << spec.programMemoryWords << " words * 2 bytes/word)\n";
        output << "        " << spec.dataMemoryBytes << ",       // data memory (RAM)\n";
        output << "        " << spec.eepromBytes << ",     // EEPROM\n";
        output << "        Architecture::" << spec.architecture << "\n";
        output << "    };\n\n";
    }

    output.close();
    std::cout << "Generated " << outputFile << " with " << specs.size() << " device specifications" << std::endl;

    // Generate lookup function code
    std::ofstream lookupFile("device_lookup_generated.cpp");
    if (lookupFile.is_open()) {
        lookupFile << "// Auto-generated device lookup code\n";
        lookupFile << "// This code should replace the content of getDeviceSpecByName() in device_specs.cpp\n\n";

        for (const auto& spec : specs) {
            lookupFile << "    if (deviceName == \"" << spec.name << "\") return "
                      << spec.name << "_SPEC;\n";
        }

        lookupFile << "\n    return std::nullopt;  // Device not found\n";

        lookupFile.close();
        std::cout << "Generated device_lookup_generated.cpp with lookup code" << std::endl;
    }

    return 0;
}
